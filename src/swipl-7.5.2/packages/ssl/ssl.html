<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>SWI-Prolog SSL Interface</title>
<style type="text/css">

/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef, dt.multidef
{ color: #fff;
padding: 2px 10px 0px 10px;
margin-bottom: 5px;
font-size: 18px;
vertical-align: middle;
overflow: hidden;
}

dt.pubdef { background-color: #0c3d6e; }
dt.multidef { background-color: #ef9439; }

.bib dd
{ margin-bottom: 1em;
}

.bib dt
{ float: left;
margin-right: 1.3ex;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{
}

span.sec-title
{
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
padding-top: 0.2em;
font-size: 80%;
font-style: italic;
color: #fff;
}

div.caption
{ width: 80%;
margin: auto;
text-align:center;
}

/* Footnotes */
.fn {
color: red;
font-size: 70%;
}

.fn-text, .fnp {
position: absolute;
top: auto;
left: 10%;
border: 1px solid #000;
box-shadow: 5px 5px 5px #888;
display: none;
background: #fff;
color: #000;
margin-top: 25px;
padding: 8px 12px;
font-size: larger;
}

sup:hover span.fn-text
{ display: block;
}

/* Lists */

dl.latex
{ margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.latex dl.latex dd.defbody
{ margin-bottom: 0.5ex;
}

/* PlDoc Tags */

dl.tags
{ font-size: 90%;
margin-left: 5ex;
margin-top: 1ex;
margin-bottom: 0.5ex;
}

dl.tags dt
{ margin-left: 0pt;
font-weight: bold;
}

dl.tags dd
{ margin-left: 3ex;
}

td.param
{ font-style: italic;
font-weight: bold;
}

/* Index */

dt.index-sep
{ font-weight: bold;
font-size: +1;
margin-top: 1ex;
}

/* Tables */

table.center
{ margin: auto;
}

table.latex
{ border-collapse:collapse;
}

table.latex tr
{ vertical-align: text-top;
}

table.latex td,th
{ padding: 2px 1em;
}

table.latex tr.hline td,th
{ border-top: 1px solid black;
}

table.frame-box
{ border: 2px solid black;
}

</style>
</head>
<body style="background:white"> 
<div class="title">SWI-Prolog SSL Interface</div>
<div class="author">Jan van der Steen, Matt Lilley and Jan Wielemaker <br>
<a class="url" href="http://www.diff.nl">Diff Automatisering v.o.f</a> 

<p>Jan Wielemaker <br>
SWI, University of Amsterdam <br>
The Netherlands <br>
E-mail: <a class="url" href="mailto:jan@swi-prolog.org">jan@swi-prolog.org</a></div>
<div class="abstract">
<div class="abstract-title">Abstract</div> The SWI-Prolog SSL (Secure 
Socket Layer) library implements a pair of
<em>filtered streams</em> that realises an SSL encrypted connection on 
top of a pair of Prolog <em>wire</em> streams, typically a network 
socket. SSL provides public key based encryption and digitally signed 
identity information of the <em>peer</em>. The SSL library is well 
integrated with SWI-Prolog's HTTP library for both implementing HTTPS 
servers and communicating with HTTPS servers. It is also used by the
<a class="url" href="http://www.swi-prolog.org/pack/list?p=smtp">smtp 
pack</a> for accessing secure mail agents. Plain SSL can be used to 
realise secure connections between e.g., Prolog agents.
</div>

<h1><a id="document-contents">Table of Contents</a></h1>

<div class="toc">
<div class="toc-h2"><a class="sec" href="#sec:1"><span class="sec-nr">1</span> <span class="sec-title">Introduction</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:2"><span class="sec-nr">2</span> <span class="sec-title">library(ssl): 
Secure Socket Layer (SSL) library</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:3"><span class="sec-nr">3</span> <span class="sec-title">library(crypto): 
Cryptography and authentication library</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.1"><span class="sec-nr">3.1</span> <span class="sec-title">Introduction</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.2"><span class="sec-nr">3.2</span> <span class="sec-title">Hashes 
and digests</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.3"><span class="sec-nr">3.3</span> <span class="sec-title">Digital 
signatures</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.4"><span class="sec-nr">3.4</span> <span class="sec-title">Asymmetric 
encryption and decryption</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:3.5"><span class="sec-nr">3.5</span> <span class="sec-title">Symmetric 
encryption and decryption</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:4"><span class="sec-nr">4</span> <span class="sec-title">XML 
cryptographic libraries</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.1"><span class="sec-nr">4.1</span> <span class="sec-title">library(saml): 
SAML Authentication</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.2"><span class="sec-nr">4.2</span> <span class="sec-title">library(xmlenc): 
XML encryption library</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:4.3"><span class="sec-nr">4.3</span> <span class="sec-title">library(xmldsig): 
XML Digital signature</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:5"><span class="sec-nr">5</span> <span class="sec-title">SSL 
Security</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:6"><span class="sec-nr">6</span> <span class="sec-title">CRLs 
and Revocation</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:6.1"><span class="sec-nr">6.1</span> <span class="sec-title">Disabling 
certificate checking</span></a></div>
<div class="toc-h4"><a class="sec" href="#sec:6.2"><span class="sec-nr">6.2</span> <span class="sec-title">Establishing 
a safe connection</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:7"><span class="sec-nr">7</span> <span class="sec-title">Example 
code</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:7.1"><span class="sec-nr">7.1</span> <span class="sec-title">Accessing 
an HTTPS server</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:7.2"><span class="sec-nr">7.2</span> <span class="sec-title">Creating 
an HTTPS server</span></a></div>
<div class="toc-h3"><a class="sec" href="#sec:7.3"><span class="sec-nr">7.3</span> <span class="sec-title">HTTPS 
behind a proxy</span></a></div>
<div class="toc-h2"><a class="sec" href="#sec:8"><span class="sec-nr">8</span> <span class="sec-title">Acknowledgments</span></a></div>
</div>
<h2 id="sec:ssl-intro"><a id="sec:1"><span class="sec-nr">1</span> <span class="sec-title">Introduction</span></a></h2>

<a id="sec:ssl-intro"></a>

<p>Raw TCP/IP networking is dangerous for two reasons. It is hard to 
tell whether the party you think you are talking to is indeed the right 
one and anyone with access to a subnet through which your data flows can 
`tap' the wire and listen for sensitive information such as passwords, 
credit card numbers, etc. Secure Socket Layer (SSL) deals with both 
problems. It uses certificates to establish the identity of the peer and 
encryption to make it useless to tap into the wire. SSL allows agents to 
talk in private and create secure web services.

<p>The SWI-Prolog <code>library(ssl)</code> library provides an API to 
turn a pair of arbitrary Prolog <em>wire</em> streams into SSL powered 
encrypted streams. Note that secure protocols such as secure HTTP simply 
run the plain protocol over (SSL) encrypted streams.

<p>Cryptography is a difficult topic. If you just want to download 
documents from an HTTPS server without worrying much about security,
<a id="idx:httpopen3:1"></a><span class="pred-ext">http_open/3</span> 
will do the job for you. As soon as you have higher security demands we 
strongly recommend you to read enough background material to understand 
what you are doing. See <a class="sec" href="#sec:5">section 5</a> for 
some remarks regarding this implementation. This
<a class="url" href="http://www.tldp.org/HOWTO/SSL-Certificates-HOWTO/index.html">The 
Linux Documentation Project page</a> provides some additional background 
and tips for managing certificates and keys.

<p><h2 id="sec:ssl"><a id="sec:2"><span class="sec-nr">2</span> <span class="sec-title">library(ssl): 
Secure Socket Layer (SSL) library</span></a></h2>

<p><a id="sec:ssl"></a>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<code>library(socket)</code>, <code>library(http/http_open)</code>, <code>library(crypto)</code>
</dd>
</dl>

<p>An SSL server and client can be built with the (abstracted) predicate 
calls from the table below. The <code>tcp_</code> predicates are 
provided by <code>library(socket)</code>. The predicate <a class="pred" href="#ssl_context/3">ssl_context/3</a> 
defines properties of the SSL connection, while <a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a> 
establishes the SSL connection based on the wire streams created by the 
TCP predicates and the context.
<blockquote>
<table class="latex frame-box">
<tr><td><b>The SSL Server</b> </td><td><b>The SSL Client</b> </td></tr>
<tr><td><a class="pred" href="#ssl_context/3">ssl_context/3</a> </td><td><a class="pred" href="#ssl_context/3">ssl_context/3</a> </td></tr>
<tr><td><span class="pred-ext">tcp_socket/1</span> </td></tr>
<tr><td><span class="pred-ext">tcp_accept/3</span> </td><td><span class="pred-ext">tcp_connect/3</span> </td></tr>
<tr><td><span class="pred-ext">tcp_open_socket/3</span> </td><td><span class="pred-ext">stream_pair/3</span> </td></tr>
<tr><td><a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a> </td><td><a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a> </td></tr>
</table>
</blockquote>

<p>The library is abstracted to communication over streams, and is not 
reliant on those streams being directly attached to sockets. The <code>tcp_</code> 
calls here are simply the most common way to use the library. Other 
two-way communication channels such as (named), pipes can just as easily 
be used.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="ssl_context/3"><strong>ssl_context</strong>(<var>+Role, 
-SSL, :Options</var>)</a></dt>
<dd class="defbody">
Create an <var>SSL</var> context. The context defines several properties 
of the <var>SSL</var> connection such as involved keys, preferred 
encryption, and passwords. After establishing a context, an <var>SSL</var> 
connection can be negotiated using <a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a>, 
turning two arbitrary plain Prolog streams into encrypted streams. This 
predicate processes the options below.

<dl class="latex">
<dt><strong>host</strong>(<var>+HostName</var>)</dt>
<dd class="defbody">
For the client, the host to which it connects. This option
<i>should</i> be specified when <var>Role</var> is <code>client</code>. 
Otherwise, certificate verification may fail when negotiating a secure 
connection.
</dd>
<dt><strong>certificate_file</strong>(<var>+FileName</var>)</dt>
<dd class="defbody">
Specify where the certificate file can be found. This can be the same as 
the <code>key_file(+FileName)</code> option. A server <i>must</i> have 
at least one certificate before clients can connect. A client
<i>must</i> have a certificate only if the server demands the client to 
identify itself with a client certificate using the
<code>peer_cert(true)</code> option. If a certificate is provided, it is 
necessary to also provide a matching <i>private key</i> via the
<span class="pred-ext">key_file/1</span> option. To configure multiple 
certificates, use the option <span class="pred-ext">certificate_key_pairs/1</span> 
instead. Alternatively, use
<a class="pred" href="#ssl_add_certificate_key/4">ssl_add_certificate_key/4</a> 
to add certificates and keys to an existing context.
</dd>
<dt><strong>key_file</strong>(<var>+FileName</var>)</dt>
<dd class="defbody">
Specify where the private key that matches the certificate can be found. 
If the key is encrypted with a password, this must be supplied using the <code>password(+Text)</code> 
or
<code>pem_password_hook(:Goal)</code> option.
</dd>
<dt><strong>certificate_key_pairs</strong>(<var>+Pairs</var>)</dt>
<dd class="defbody">
Alternative method for specifying certificates and keys. The argument is 
a list of <i>pairs</i> of the form Certificate-Key, where each component 
is a string or an atom that holds, respectively, the PEM-encoded 
certificate and key. To each certificate, further certificates of the 
chain can be appended. Multiple types of certificates can be present at 
the same time to enable different ciphers. Using multiple certificate 
types with completely independent certificate chains requires OpenSSL 
1.0.2 or greater.
</dd>
<dt><strong>password</strong>(<var>+Text</var>)</dt>
<dd class="defbody">
Specify the password the private key is protected with (if any). If you 
do not want to store the password you can also specify an application 
defined handler to return the password (see next option). <var>Text</var> 
is either an atom or string. Using a string is preferred as strings are 
volatile and local resources.
</dd>
<dt><strong>pem_password_hook</strong>(<var>:Goal</var>)</dt>
<dd class="defbody">
In case a password is required to access the private key the supplied 
predicate will be called to fetch it. The hook is called as <code>call(Goal, +SSL, -Password)</code> 
and typically unifies
<var>Password</var> with a <i>string</i> containing the password.
</dd>
<dt><strong>require_crl</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If true (default is false), then all certificates will be considered 
invalid unless they can be verified as not being revoked. You can do 
this explicity by passing a list of CRL filenames via the <span class="pred-ext">crl/1</span> 
option, or by doing it yourself in the cert_verify_hook. If you specify <code>require_crl(true)</code> 
and provide neither of these options, verification will necessarily fail
</dd>
<dt><strong>crl</strong>(<var>+ListOfFileNames</var>)</dt>
<dd class="defbody">
Provide a list of filenames of PEM-encoded CRLs that will be given to 
the context to attempt to establish that a chain of certificates is not 
revoked. You must also set <code>require_crl(true)</code> if you want 
CRLs to actually be checked by OpenSSL.
</dd>
<dt><strong>cacert_file</strong>(<var>+FileName</var>)</dt>
<dd class="defbody">
Specify a file containing certificate keys of <i>trusted</i> 
certificates. The peer is trusted if its certificate is signed 
(ultimately) by one of the provided certificates. Using the <var>FileName</var> <code>system(root_certificates)</code> 
uses a list of trusted root certificates as provided by the OS. See
<a class="pred" href="#system_root_certificates/1">system_root_certificates/1</a> 
for details.

<p>Additional verification of the peer certificate as well as accepting 
certificates that are not trusted by the given set can be realised using 
the hook cert_verify_hook(:Goal).
</dd>
<dt><strong>cert_verify_hook</strong>(<var>:Goal</var>)</dt>
<dd class="defbody">
The predicate <a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a> 
calls <var>Goal</var> as follows:

<pre class="code">
call(Goal, +SSL,
     +ProblemCertificate, +AllCertificates, +FirstCertificate,
     +Error)
</pre>

<p>In case the certificate was verified by one of the provided 
certifications from the <code>cacert_file</code> option, Error is 
unified with the atom <code>verified</code>. Otherwise it contains the 
error string passed from OpenSSL. Access will be granted iff the 
predicate succeeds. See <a class="pred" href="#load_certificate/2">load_certificate/2</a> 
for a description of the certificate terms. See <a class="pred" href="#cert_accept_any/5">cert_accept_any/5</a> 
for a dummy implementation that accepts any certificate.
</dd>
<dt><strong>cipher_list</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
Specify a cipher preference list (one or more cipher strings separated 
by colons, commas or spaces).
</dd>
<dt><strong>ecdh_curve</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
Specify a curve for ECDHE ciphers. If this option is not specified, the 
OpenSSL default parameters are used. With OpenSSL prior to 1.1.0, <code>prime256v1</code> 
is used by default.
</dd>
<dt><strong>peer_cert</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
Trigger the request of our peer's certificate while establishing the <var>SSL</var> 
layer. This option is automatically turned on in a client <var>SSL</var> 
socket. It can be used in a server to ask the client to identify itself 
using an <var>SSL</var> certificate.
</dd>
<dt><strong>close_parent</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code>, close the raw streams if the <var>SSL</var> 
streams are closed. Default is <code>false</code>.
</dd>
<dt><strong>close_notify</strong>(<var>+Boolean</var>)</dt>
<dd class="defbody">
If <code>true</code> (default is <code>false</code>), the server sends 
TLS
<code>close_notify</code> when closing the connection. In addition, this 
mitigates <i>truncation attacks</i> for both client and server role: If 
EOF is encountered without having received a TLS shutdown, an exception 
is raised. Well-designed protocols are self-terminating, and this attack 
is therefore very rarely a concern.
</dd>
<dt><strong>min_protocol_version</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
Set the <i>minimum</i> protocol version that can be negotiated.
<var>Atom</var> is one of <code>sslv3</code>, <code>tlsv1</code>, <code>tlsv1_1</code> 
and <code>tlsv1_2</code>. This option is available with OpenSSL 1.1.0 
and later, and should be used instead of <code>disable_ssl_methods/1</code>.
</dd>
<dt><strong>max_protocol_version</strong>(<var>+Atom</var>)</dt>
<dd class="defbody">
Set the <i>maximum</i> protocol version that can be negotiated.
<var>Atom</var> is one of <code>sslv3</code>, <code>tlsv1</code>, <code>tlsv1_1</code> 
and <code>tlsv1_2</code>. This option is available with OpenSSL 1.1.0 
and later, and should be used instead of <code>disable_ssl_methods/1</code>.
</dd>
<dt><strong>disable_ssl_methods</strong>(<var>+List</var>)</dt>
<dd class="defbody">
A list of methods to disable. Unsupported methods will be ignored. 
Methods include <code>sslv2</code>, <code>sslv3</code>, <code>sslv23</code>,
<code>tlsv1</code>, <code>tlsv1_1</code> and <code>tlsv1_2</code>. This 
option is deprecated starting with OpenSSL 1.1.0. Use <span class="pred-ext">min_protocol_version/1</span> 
and
<span class="pred-ext">max_protocol_version/1</span> instead.
</dd>
<dt><strong>ssl_method</strong>(<var>+Method</var>)</dt>
<dd class="defbody">
Specify the explicit <var>Method</var> to use when negotiating. For 
allowed values, see the list for <code>disable_ssl_methods</code> above. 
Using this option is discouraged. When using OpenSSL 1.1.0 or later, 
this option is ignored, and a version-flexible method is used to 
negotiate the connection. Using version-specific methods is deprecated 
in recent OpenSSL versions, and this option will become obsolete and 
ignored in the future.
</dd>
<dt><strong>sni_hook</strong>(<var>:Goal</var>)</dt>
<dd class="defbody">
This option provides Server Name Indication (SNI) for <var>SSL</var> 
servers. This means that depending on the host to which a client 
connects, different options (certificates etc.) can be used for the 
server. This TLS extension allows you to host different domains using 
the same IP address and physical machine. When a TLS connection is 
negotiated with a client that has provided a host name via SNI, the hook 
is called as follows:

<pre class="code">
call(Goal, +SSL0, +HostName, -SSL)
</pre>

<p>Given the current context SSL0, and the host name of the client 
request, the predicate computes <var>SSL</var> which is used as the 
context for negotiating the connection. The first solution is used. If 
the predicate fails, the default options are used, which are those of 
the encompassing <a class="pred" href="#ssl_context/3">ssl_context/3</a> 
call. In that case, if no default certificate and key are specified, the 
client connection is rejected.
</dd>
</dl>

<table class="arglist">
<tr><td><var>Role</var> </td><td>is one of <code>server</code> or <code>client</code> 
and denotes whether the
<var>SSL</var> instance will have a server or client role in the 
established connection. </td></tr>
<tr><td><var>SSL</var> </td><td>is a SWI-Prolog <i>blob</i> of type <code>ssl_context</code>, 
i.e., the type-test for an <var>SSL</var> context is <code>blob(SSL, ssl_context)</code>. </td></tr>
</table>
</dd>
<dt class="pubdef"><a id="ssl_add_certificate_key/4"><strong>ssl_add_certificate_key</strong>(<var>+SSL0, 
+Certificate, +Key, -SSL</var>)</a></dt>
<dd class="defbody">
Add an additional certificate/key pair to <var>SSL0</var>, yielding <var>SSL</var>.
<var>Certificate</var> and <var>Key</var> are either strings or atoms 
that hold the PEM-encoded certificate plus certificate chain and private 
key, respectively. Using strings is preferred for security reasons.

<p>This predicate allows dual-stack RSA and ECDSA servers (for example), 
and is an alternative for using the
<code>certificate_key_pairs/1</code> option. As of OpenSSL 1.0.2, 
multiple certificate types with completely independent certificate 
chains are supported. If a certificate of the same type is added 
repeatedly to a context, the result is undefined. Currently, up to 12 
additional certificates of different types are admissible.</dd>
<dt class="pubdef"><a id="ssl_set_sni_hook/3"><strong>ssl_set_sni_hook</strong>(<var>+SSL0, 
:Goal, -SSL</var>)</a></dt>
<dd class="defbody">
<var>SSL</var> is the same as <var>SSL0</var>, except that the SNI hook 
of <var>SSL</var> is <var>Goal</var>. See the sni_hook(:<var>Goal</var>) 
option of <a class="pred" href="#ssl_context/3">ssl_context/3</a> for 
more information about this hook.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="ssl_negotiate/5"><strong>ssl_negotiate</strong>(<var>+SSL, 
+PlainRead, +PlainWrite, -SSLRead, -SSLWrite</var>)</a></dt>
<dd class="defbody">
Once a connection is established and a read/write stream pair is 
available, (<var>PlainRead</var> and <var>PlainWrite</var>), this 
predicate can be called to negotiate an <var>SSL</var> session over the 
streams. If the negotiation is successful, <var>SSLRead</var> and <var>SSLWrite</var> 
are returned.

<p>After a successful handshake and finishing the communication the user 
must close <var>SSLRead</var> and <var>SSLWrite</var>, for example using
<code>call_cleanup(close(SSLWrite), close(SSLRead))</code>. If the <var>SSL</var>
<i>context</i> (created with <a class="pred" href="#ssl_context/3">ssl_context/3</a> 
has the option
<code>close_parent(true)</code> (default <code>false</code>), closing <var>SSLRead</var> 
and
<var>SSLWrite</var> also closes the original <var>PlainRead</var> and <var>PlainWrite</var> 
streams. Otherwise these must be closed explicitly by the user.

<dl class="tags">
<dt class="tag">Errors</dt>
<dd>
<code>ssl_error(Code, LibName, FuncName, Reason)</code> is raised if the 
negotiation fails. The streams <var>PlainRead</var> and <var>PlainWrite</var> 
are <b>not</b> closed, but an unknown amount of data may have been read 
and written.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="ssl_peer_certificate/2"><strong>ssl_peer_certificate</strong>(<var>+Stream, 
-Certificate</var>)</a></dt>
<dd class="defbody">
True if the peer certificate is provided (this is always the case for a 
client connection) and <var>Certificate</var> unifies with the peer 
certificate. The example below uses this to obtain the
<i>Common Name</i> of the peer after establishing an https client 
connection:

<pre class="code">
  http_open(HTTPS_url, In, []),
  ssl_peer_certificate(In, Cert),
  memberchk(subject(Subject), Cert),
  memberchk('CN' = CommonName), Subject)
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="ssl_peer_certificate_chain/2"><strong>ssl_peer_certificate_chain</strong>(<var>+Stream, 
-Certificates</var>)</a></dt>
<dd class="defbody">
<var>Certificates</var> is the certificate chain provided by the peer, 
represented as a list of certificates.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="ssl_session/2"><strong>ssl_session</strong>(<var>+Stream, 
-Session</var>)</a></dt>
<dd class="defbody">
Retrieves (debugging) properties from the SSL context associated with <var>Stream</var>. 
If <var>Stream</var> is not an SSL stream, the predicate raises a domain 
error. <var>Session</var> is a list of properties, containing the 
members described below. Except for <var>Version</var>, all information 
are byte arrays that are represented as Prolog strings holding 
characters in the range 0..255.

<dl class="latex">
<dt><strong>ssl_version</strong>(<var>Version</var>)</dt>
<dd class="defbody">
The negotiated version of the session as an integer.
</dd>
<dt><strong>cipher</strong>(<var>Cipher</var>)</dt>
<dd class="defbody">
The negotiated cipher for this connection.
</dd>
<dt><strong>session_key</strong>(<var>Key</var>)</dt>
<dd class="defbody">
The key material used in SSLv2 connections (if present).
</dd>
<dt><strong>master_key</strong>(<var>Key</var>)</dt>
<dd class="defbody">
The key material comprising the master secret. This is generated from 
the server_random, client_random and pre-master key.
</dd>
<dt><strong>client_random</strong>(<var>Random</var>)</dt>
<dd class="defbody">
The random data selected by the client during handshaking.
</dd>
<dt><strong>server_random</strong>(<var>Random</var>)</dt>
<dd class="defbody">
The random data selected by the server during handshaking.
</dd>
<dt><strong>session_id</strong>(<var>SessionId</var>)</dt>
<dd class="defbody">
The SSLv3 session ID. Note that if ECDHE is being used (which is the 
default for newer versions of OpenSSL), this data will not actually be 
sent to the server.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="load_certificate/2"><strong>load_certificate</strong>(<var>+Stream, 
-Certificate</var>)</a></dt>
<dd class="defbody">
Loads a certificate from a PEM- or DER-encoded stream, returning a term 
which will unify with the same certificate if presented in 
cert_verify_hook. A certificate is a list containing the following 
terms: <span class="pred-ext">issuer_name/1</span>, <span class="pred-ext">hash/1</span>, <span class="pred-ext">signature/1</span>,
<span class="pred-ext">signature_algorithm/1</span>, <span class="pred-ext">version/1</span>, <span class="pred-ext">notbefore/1</span>, <span class="pred-ext">notafter/1</span>,
<span class="pred-ext">serial/1</span>, <span class="pred-ext">subject/1</span> 
and <span class="pred-ext">key/1</span>. <span class="pred-ext">subject/1</span> 
and <span class="pred-ext">issuer_name/1</span> are both lists of <span class="pred-ext">=/2</span> 
terms representing the name. With OpenSSL 1.0.2 and greater, <span class="pred-ext">to_be_signed/1</span> 
is also available, yielding the hexadecimal representation of the TBS 
(to-be-signed) portion of the certificate.

<p>Note that the OpenSSL <code>CA.pl</code> utility creates certificates 
that have a human readable textual representation in front of the PEM 
representation. You can use the following to skip to the certificate if 
you know it is a PEM certificate:

<pre class="code">
skip_to_pem_cert(In) :-
      repeat,
      (   peek_char(In, '-')
      -&gt;  !
      ;   skip(In, 0'\n),
          at_end_of_stream(In), !
      ).
</pre>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="load_crl/2"><strong>load_crl</strong>(<var>+Stream, 
-CRL</var>)</a></dt>
<dd class="defbody">
Loads a <var>CRL</var> from a PEM- or DER-encoded stream, returning a 
term containing terms <span class="pred-ext">hash/1</span>, <span class="pred-ext">signature/1</span>, <span class="pred-ext">issuer_name/1</span> 
and
<span class="pred-ext">revocations/1</span>, which is a list of <span class="pred-ext">revoked/2</span> 
terms. Each
<span class="pred-ext">revoked/2</span> term is of the form <code>revoked(+Serial, DateOfRevocation)</code></dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="system_root_certificates/1"><strong>system_root_certificates</strong>(<var>-List</var>)</a></dt>
<dd class="defbody">
<var>List</var> is a list of trusted root certificates as provided by 
the OS. This is the list used by <a class="pred" href="#ssl_context/3">ssl_context/3</a> 
when using the option
<code>system(root_certificates)</code>. The list is obtained using an OS 
specific process. The current implementation is as follows:

<p>
<ul class="latex">
<li>On Windows, CertOpenSystemStore() is used to import the <code>"ROOT"</code> 
certificates from the OS.
<li>On MacOSX, the trusted keys are loaded from the
<i>SystemRootCertificates</i> key chain. The Apple API for this requires 
the SSL interface to be compiled with an XCode compiler, i.e., <b>not</b> 
with native gcc.
<li>Otherwise, certificates are loaded from a file defined by the Prolog 
flag <code>system_cacert_filename</code>. The initial value of this flag 
is operating system dependent. For security reasons, the flag can only 
be set prior to using the SSL library. For example:

<pre class="code">
:- use_module(library(ssl)).
:- set_prolog_flag(system_cacert_filename,
                   '/home/jan/ssl/ca-bundle.crt').
</pre>

<p>
</ul>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="load_private_key/3"><strong>load_private_key</strong>(<var>+Stream, 
+Password, -PrivateKey</var>)</a></dt>
<dd class="defbody">
Load a private key <var>PrivateKey</var> from the given stream <var>Stream</var>, 
using <var>Password</var> to decrypt the key if it is encrypted. Note 
that the password is currently only supported for PEM files. DER-encoded 
keys which are password protected will not load. The key must be an RSA 
or EC key. DH and DSA keys are not supported, and <var>PrivateKey</var> 
will be bound to an atom (dh_key or dsa_key) if you try and load such a 
key. Otherwise <var>PrivateKey</var> will be unified with <code>private_key(KeyTerm)</code> 
where KeyTerm is an <span class="pred-ext">rsa/8</span> term 
representing an RSA key, or <span class="pred-ext">ec/3</span> for EC 
keys.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="load_public_key/2"><strong>load_public_key</strong>(<var>+Stream, 
-PublicKey</var>)</a></dt>
<dd class="defbody">
Load a public key <var>PublicKey</var> from the given stream <var>Stream</var>. 
Supports loading both DER- and PEM-encoded keys. The key must be an RSA 
or EC key. DH and DSA keys are not supported, and
<var>PublicKey</var> will be bound to an atom (dh_key or dsa_key) if you 
try and load such a key. Otherwise <var>PublicKey</var> will be unified 
with <code>public_key(KeyTerm)</code> where KeyTerm is an <span class="pred-ext">rsa/8</span> 
term representing an RSA key, or <span class="pred-ext">ec/3</span> for 
EC keys.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="cert_accept_any/5"><strong>cert_accept_any</strong>(<var>+SSL, 
+ProblemCertificate, +AllCertificates, +FirstCertificate, +Error</var>)</a></dt>
<dd class="defbody">
Implementation for the hook `cert_verify_hook(:Hook)` that accepts <i>any</i> 
certificate. This is intended for <span class="pred-ext">http_open/3</span> 
if no certificate verification is desired as illustrated below.

<pre class="code">
  http_open('https:/...', In,
            [ cert_verify_hook(cert_accept_any)
            ])
</pre>

<p></dd>
</dl>

<p><h2 id="sec:crypto"><a id="sec:3"><span class="sec-nr">3</span> <span class="sec-title">library(crypto): 
Cryptography and authentication library</span></a></h2>

<a id="sec:crypto"></a>

<p><a id="sec:crypto"></a>

<dl class="tags">
<dt class="tag">author</dt>
<dd>
<a class="url" href="https://www.metalevel.at">Markus Triska</a>
</dd>
<dt class="tag">author</dt>
<dd>
Matt Lilley
</dd>
</dl>

<p><h3 id="sec:crypto-introduction"><a id="sec:3.1"><span class="sec-nr">3.1</span> <span class="sec-title">Introduction</span></a></h3>

<p><a id="sec:crypto-introduction"></a>

<p>This library provides bindings to functionality of OpenSSL that is 
related to cryptography and authentication, not necessarily involving 
connections, sockets or streams.

<p><h3 id="sec:crypto-hash"><a id="sec:3.2"><span class="sec-nr">3.2</span> <span class="sec-title">Hashes 
and digests</span></a></h3>

<p><a id="sec:crypto-hash"></a>

<p>A <b>hash</b>, also called <b>digest</b>, is a way to verify the 
integrity of data. In typical cases, a hash is significantly shorter 
than the data itself, and already miniscule changes in the data lead to 
different hashes.

<p>The hash functionality of this library subsumes and extends that of
<code>library(sha)</code>, <code>library(hash_stream)</code> and <code>library(md5)</code> 
by providing a unified interface to all available digest algorithms.

<p>The underlying OpenSSL library (<code>libcrypto</code>) is 
dynamically loaded if
<i>either</i> <code>library(crypto)</code> or <code>library(ssl)</code> 
are loaded. Therefore, if your application uses <code>library(ssl)</code>, 
you can use <code>library(crypto)</code> for hashing without increasing 
the memory footprint of your application. In other cases, the 
specialised hashing libraries are more lightweight but less general 
alternatives to <code>library(crypto)</code>.

<p>The most important predicates to compute hashes are:

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="crypto_data_hash/3"><strong>crypto_data_hash</strong>(<var>+Data, 
-Hash, +Options</var>)</a></dt>
<dd class="defbody">
<var>Hash</var> is the hash of <var>Data</var>. The conversion is 
controlled by <var>Options</var>:

<dl class="latex">
<dt><strong>algorithm</strong>(<var>+Algorithm</var>)</dt>
<dd class="defbody">
One of <code>md5</code>, <code>sha1</code>, <code>sha224</code>, <code>sha256</code> 
(default), <code>sha384</code>,
<code>sha512</code>, <code>blake2s256</code> or <code>blake2b512</code>. 
The <code>BLAKE</code> digest algorithms require OpenSSL 1.1.0 or 
greater.
</dd>
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
If <var>Data</var> is a sequence of character <i>codes</i>, this must be 
translated into a sequence of <i>bytes</i>, because that is what the 
hashing requires. The default encoding is <code>utf8</code>. The other 
meaningful value is <code>octet</code>, claiming that <var>Data</var> 
contains raw bytes.
</dd>
<dt><strong>hmac</strong>(<var>+Key</var>)</dt>
<dd class="defbody">
If this option is specified, a <i>hash-based message authentication code</i> 
(HMAC) is computed, using the specified <var>Key</var> which is either 
an atom or string. Any of the available digest algorithms can be used 
with this option. The cryptographic strength of the HMAC depends on that 
of the chosen algorithm and also on the key. This option requires 
OpenSSL 1.1.0 or greater.
</dd>
</dl>

<table class="arglist">
<tr><td><var>Data</var> </td><td>is either an atom, string or code-list </td></tr>
<tr><td><var>Hash</var> </td><td>is an atom that represents the hash. </td></tr>
</table>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#hex_bytes/2">hex_bytes/2</a> for conversion 
between hashes and lists.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="crypto_file_hash/3"><strong>crypto_file_hash</strong>(<var>+File, 
-Hash, +Options</var>)</a></dt>
<dd class="defbody">
True if <var>Hash</var> is the hash of the content of <var>File</var>. 
For <var>Options</var>, see <a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a>.
</dd>
</dl>

<p>For further reasoning and conversion of digests in hexadecimal 
notation, the following bidirectional relation is provided:

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="hex_bytes/2"><strong>hex_bytes</strong>(<var>?Hex, 
?List</var>)</a></dt>
<dd class="defbody">
Relation between a hexadecimal sequence and a list of bytes. <var>Hex</var> 
is an atom, string, list of characters or list of codes in hexadecimal 
encoding. This is the format that is used by
<a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a> and 
related predicates to represent <i>hashes</i>. Bytes is a list of <i>integers</i> 
between 0 and 255 that represent the sequence as a list of bytes. At 
least one of the arguments must be instantiated. When converting <var>List</var> <i>to</i> <var>Hex</var>, 
an <i>atom</i> is used to represent the sequence of hexadecimal digits.

<p>Example:

<pre class="code">
?- hex_bytes('501ACE', Bs).
Bs = [80, 26, 206].
</pre>

<p></dd>
</dl>

<p>In addition, the following predicates are provided for building 
hashes
<i>incrementally</i>. This works by first creating a <b>context</b> with
<a class="pred" href="#crypto_context_new/2">crypto_context_new/2</a>, 
then using this context with <a class="pred" href="#crypto_data_context/3">crypto_data_context/3</a> 
to incrementally obtain further contexts, and finally extract the 
resulting hash with <a class="pred" href="#crypto_context_hash/2">crypto_context_hash/2</a>.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="crypto_context_new/2"><strong>crypto_context_new</strong>(<var>-Context, 
+Options</var>)</a></dt>
<dd class="defbody">
<var>Context</var> is unified with the empty context, taking into 
account
<var>Options</var>. The context can be used in <a class="pred" href="#crypto_data_context/3">crypto_data_context/3</a>. 
For
<var>Options</var>, see <a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a>.
<table class="arglist">
<tr><td><var>Context</var> </td><td>is an opaque pure Prolog term that 
is subject to garbage collection. </td></tr>
</table>
</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="crypto_data_context/3"><strong>crypto_data_context</strong>(<var>+Data, 
+Context0, -Context</var>)</a></dt>
<dd class="defbody">
<var>Context0</var> is an existing computation context, and <var>Context</var> 
is the new context after hashing <var>Data</var> in addition to the 
previously hashed data. <var>Context0</var> may be produced by a prior 
invocation of either <a class="pred" href="#crypto_context_new/2">crypto_context_new/2</a> 
or <a class="pred" href="#crypto_data_context/3">crypto_data_context/3</a> 
itself.

<p>This predicate allows a hash to be computed in chunks, which may be 
important while working with Metalink (RFC 5854), BitTorrent or similar 
technologies, or simply with big files.</dd>
<dt class="pubdef"><a id="crypto_context_hash/2"><strong>crypto_context_hash</strong>(<var>+Context, 
-Hash</var>)</a></dt>
<dd class="defbody">
Obtain the hash code of <var>Context</var>. <var>Hash</var> is an atom 
representing the hash code that is associated with the current state of 
the computation context <var>Context</var>.
</dd>
</dl>

<p>The following hashing predicates work over <i>streams</i>:

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="crypto_open_hash_stream/3"><strong>crypto_open_hash_stream</strong>(<var>+OrgStream, 
-HashStream, +Options</var>)</a></dt>
<dd class="defbody">
Open a filter stream on <var>OrgStream</var> that maintains a hash. The 
hash can be retrieved at any time using <a class="pred" href="#crypto_stream_hash/2">crypto_stream_hash/2</a>. 
Available
<var>Options</var> in addition to those of <a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a> 
are:

<dl class="latex">
<dt><strong>close_parent</strong>(<var>+Bool</var>)</dt>
<dd class="defbody">
If <code>true</code> (default), closing the filter stream also closes 
the original (parent) stream.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="crypto_stream_hash/2"><strong>crypto_stream_hash</strong>(<var>+HashStream, 
-Hash</var>)</a></dt>
<dd class="defbody">
Unify <var>Hash</var> with a hash for the bytes sent to or read from
<var>HashStream</var>. Note that the hash is computed on the stream 
buffers. If the stream is an output stream, it is first flushed and the 
Digest represents the hash at the current location. If the stream is an 
input stream the Digest represents the hash of the processed input 
including the already buffered data.
</dd>
</dl>

<p><h3 id="sec:crypto-signatures"><a id="sec:3.3"><span class="sec-nr">3.3</span> <span class="sec-title">Digital 
signatures</span></a></h3>

<p><a id="sec:crypto-signatures"></a>

<p>A digital <b>signature</b> is a relation between a key and data that 
only someone who knows the key can compute.

<p><i>Signing</i> uses a <i>private</i> key, and <i>verifying</i> a 
signature uses the corresponding <i>public</i> key of the signing 
entity. This library supports both RSA and ECDSA signatures. You can use <a class="pred" href="#load_private_key/3">load_private_key/3</a> 
and
<a class="pred" href="#load_public_key/2">load_public_key/2</a> to load 
keys from files and streams.

<p>In typical cases, we use this mechanism to sign the <i>hash</i> of 
data. See hashing (<a class="sec" href="#sec:3.2">section 3.2</a>). For 
this reason, the following predicates work on the <i>hexadecimal</i> 
representation of hashes that is also used by
<a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a> and 
related predicates:

<dl class="latex">
<dt class="pubdef"><a id="ecdsa_sign/4"><strong>ecdsa_sign</strong>(<var>+Key, 
+Data, -Signature, +Options</var>)</a></dt>
<dd class="defbody">
Create an ECDSA signature for <var>Data</var> with EC private key <var>Key</var>. 
Among the most common cases is signing a hash that was created with <a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a> 
or other predicates of this library. For this reason, the default 
encoding (<code>hex</code>) assumes that <var>Data</var> is an atom, 
string, character list or code list representing the data in hexadecimal 
notation. See <a class="pred" href="#rsa_sign/4">rsa_sign/4</a> for an 
example.

<p><var>Options</var>:

<dl class="latex">
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> to use for <var>Data</var>. Default is <code>hex</code>. 
Alternatives are <code>octet</code>, <code>utf8</code> and <code>text</code>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="ecdsa_verify/4"><strong>ecdsa_verify</strong>(<var>+Key, 
+Data, +Signature, +Options</var>)</a></dt>
<dd class="defbody">
True iff <var>Signature</var> can be verified as the ECDSA signature for
<var>Data</var>, using the EC public key <var>Key</var>.

<p><var>Options</var>:

<dl class="latex">
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> to use for <var>Data</var>. Default is <code>hex</code>. 
Alternatives are <code>octet</code>, <code>utf8</code> and <code>text</code>.
</dd>
</dl>

</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rsa_sign/4"><strong>rsa_sign</strong>(<var>+Key, 
+Data, -Signature, +Options</var>)</a></dt>
<dd class="defbody">
Create an RSA signature for <var>Data</var> with private key <var>Key</var>. <var>Options</var>:

<dl class="latex">
<dt><strong>type</strong>(<var>+Type</var>)</dt>
<dd class="defbody">
SHA algorithm used to compute the digest. Values are
<code>sha1</code> (default), <code>sha224</code>, <code>sha256</code>, <code>sha384</code> 
or <code>sha512</code>.
</dd>
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> to use for <var>Data</var>. Default is <code>hex</code>. 
Alternatives are <code>octet</code>, <code>utf8</code> and <code>text</code>.
</dd>
</dl>

<p>This predicate can be used to compute a <code>sha256WithRSAEncryption</code> 
signature as follows:

<pre class="code">
sha256_with_rsa(PemKeyFile, Password, Data, Signature) :-
    Algorithm = sha256,
    read_key(PemKeyFile, Password, Key),
    crypto_data_hash(Data, Hash, [algorithm(Algorithm),
                                  encoding(octet)]),
    rsa_sign(Key, Hash, Signature, [type(Algorithm)]).

read_key(File, Password, Key) :-
    setup_call_cleanup(
        open(File, read, In, [type(binary)]),
        load_private_key(In, Password, Key),
        close(In)).
</pre>

<p>Note that a hash that is computed by <a class="pred" href="#crypto_data_hash/3">crypto_data_hash/3</a> 
can be directly used in <a class="pred" href="#rsa_sign/4">rsa_sign/4</a> 
as well as <a class="pred" href="#ecdsa_sign/4">ecdsa_sign/4</a>.</dd>
<dt class="pubdef"><span class="pred-tag">[semidet]</span><a id="rsa_verify/4"><strong>rsa_verify</strong>(<var>+Key, 
+Data, +Signature, +Options</var>)</a></dt>
<dd class="defbody">
Verify an RSA signature for <var>Data</var> with public key <var>Key</var>.

<p><var>Options</var>:

<dl class="latex">
<dt><strong>type</strong>(<var>+Type</var>)</dt>
<dd class="defbody">
SHA algorithm used to compute the digest. Values are
<code>sha1</code> (default), <code>sha224</code>, <code>sha256</code>, <code>sha384</code> 
or <code>sha512</code>.
</dd>
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> to use for <var>Data</var>. Default is <code>hex</code>. 
Alternatives are <code>octet</code>, <code>utf8</code> and <code>text</code>.
</dd>
</dl>

</dd>
</dl>

<p>Signatures are also represented in hexadecimal notation, and you can 
use <a class="pred" href="#hex_bytes/2">hex_bytes/2</a> to convert them 
to and from lists of bytes (integers).

<p><h3 id="sec:crypto-asymmetric"><a id="sec:3.4"><span class="sec-nr">3.4</span> <span class="sec-title">Asymmetric 
encryption and decryption</span></a></h3>

<p><a id="sec:crypto-asymmetric"></a>

<p>The following predicates provide <i>asymmetric</i> RSA encryption and 
decryption. This means that the key that is used for <i>encryption</i> 
is different from the one used to <i>decrypt</i> the data:

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rsa_private_decrypt/4"><strong>rsa_private_decrypt</strong>(<var>+PrivateKey, 
+CipherText, -PlainText, +Options</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rsa_private_encrypt/4"><strong>rsa_private_encrypt</strong>(<var>+PrivateKey, 
+PlainText, -CipherText, +Options</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rsa_public_decrypt/4"><strong>rsa_public_decrypt</strong>(<var>+PublicKey, 
+CipherText, -PlainText, +Options</var>)</a></dt>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="rsa_public_encrypt/4"><strong>rsa_public_encrypt</strong>(<var>+PublicKey, 
+PlainText, -CipherText, +Options</var>)</a></dt>
<dd class="defbody">
RSA Public key encryption and decryption primitives. A string can be 
safely communicated by first encrypting it and have the peer decrypt it 
with the matching key and predicate. The length of the string is limited 
by the key length.

<p><var>Options</var>:

<dl class="latex">
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> to use for Data. Default is <code>utf8</code>. 
Alternatives are <code>utf8</code> and <code>octet</code>.
</dd>
<dt><strong>padding</strong>(<var>+PaddingScheme</var>)</dt>
<dd class="defbody">
Padding scheme to use. Default is <code>pkcs1</code>. Alternatives are <code>pkcs1_oaep</code>, <code>sslv23</code> 
and <code>none</code>. Note that <code>none</code> should only be used 
if you implement cryptographically sound padding modes in your 
application code as encrypting unpadded data with RSA is insecure
</dd>
</dl>

<dl class="tags">
<dt class="tag">Errors</dt>
<dd>
<code>ssl_error(Code, LibName, FuncName, Reason)</code> is raised if 
there is an error, e.g., if the text is too long for the key.
</dd>
<dt class="tag">See also</dt>
<dd>
<a class="pred" href="#load_private_key/3">load_private_key/3</a>, <a class="pred" href="#load_public_key/2">load_public_key/2</a> 
can be use to load keys from a file. The predicate <a class="pred" href="#load_certificate/2">load_certificate/2</a> 
can be used to obtain the public key from a certificate.
</dd>
</dl>

</dd>
</dl>

<p><h3 id="sec:crypto-symmetric"><a id="sec:3.5"><span class="sec-nr">3.5</span> <span class="sec-title">Symmetric 
encryption and decryption</span></a></h3>

<p><a id="sec:crypto-symmetric"></a>

<p>The following predicates provide <i>symmetric</i> encryption and 
decryption:

<dl class="latex">
<dt class="pubdef"><a id="evp_decrypt/6"><strong>evp_decrypt</strong>(<var>+CipherText, 
+Algorithm, +Key, +IV, -PlainText, +Options</var>)</a></dt>
<dd class="defbody">
Decrypt the given <var>CipherText</var>, using the symmetric algorithm
<var>Algorithm</var>, key <var>Key</var>, and iv <var>IV</var>, to give <var>PlainText</var>. <var>CipherText</var>, <var>Key</var> 
and <var>IV</var> should all be strings, and <var>PlainText</var> is 
created as a string as well. <var>Algorithm</var> should be an algorithm 
which your copy of OpenSSL knows about. Examples are:

<p>
<ul class="compact">
<li>aes-128-cbc
<li>aes-256-cbc
<li>des3
</ul>

<p>If the <var>IV</var> is not needed for your decryption algorithm 
(such as aes-128-ecb) then any string can be provided as it will be 
ignored by the underlying implementation

<p><var>Options</var>:

<dl class="latex">
<dt><strong>encoding</strong>(<var>+Encoding</var>)</dt>
<dd class="defbody">
<var>Encoding</var> to use for Data. Default is <code>utf8</code>. 
Alternatives are <code>utf8</code> and <code>octet</code>.
</dd>
<dt><strong>padding</strong>(<var>+PaddingScheme</var>)</dt>
<dd class="defbody">
Padding scheme to use. Default is <code>block</code>. You can disable 
padding by supplying
<code>none</code> here.
</dd>
</dl>

<p>Example of aes-128-cbc encryption:

<pre class="code">
?- evp_encrypt("this is some input", 'aes-128-cbc', "sixteenbyteofkey",
               "sixteenbytesofiv", CipherText, []),
   evp_decrypt(CipherText, 'aes-128-cbc',
               "sixteenbyteofkey", "sixteenbytesofiv",
               RecoveredText, []).
CipherText = &lt;binary string&gt;
RecoveredText = "this is some input".
</pre>

</dd>
<dt class="pubdef"><a id="evp_encrypt/6"><strong>evp_encrypt</strong>(<var>+PlainText, 
+Algorithm, +Key, +IV, -CipherTExt, +Options</var>)</a></dt>
<dd class="defbody">
Encrypt the given <var>PlainText</var>, using the symmetric algorithm
<var>Algorithm</var>, key <var>Key</var>, and iv <var>IV</var>, to give 
CipherText. See
<a class="pred" href="#evp_decrypt/6">evp_decrypt/6</a>.
</dd>
</dl>

<p><h2 id="sec:ssl-xml-libs"><a id="sec:4"><span class="sec-nr">4</span> <span class="sec-title">XML 
cryptographic libraries</span></a></h2>

<a id="sec:ssl-xml-libs"></a>

<p>The SSL package provides several libraries dealing with cryptographic 
operations of XML documents. These libraries depend on the <code>sgml</code> 
package. These libraries are part of this package because the
<code>sgml</code> package has no external dependencies and will thus be 
available in any SWI-Prolog installation while configuring and building 
this <code>ssl</code> package is much more involved.

<p><h3 id="sec:saml"><a id="sec:4.1"><span class="sec-nr">4.1</span> <span class="sec-title">library(saml): 
SAML Authentication</span></a></h3>

<p><a id="sec:saml"></a>

<dl class="tags">
<dt class="tag">See also</dt>
<dd>
<a class="url" href="https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf">https://docs.oasis-open.org/security/saml/v2.0/saml-core-2.0-os.pdf</a>
<blockquote> There are four primary integration points for applications 
to use this code: 1) You must declare at least one service provider (SP) 
2) You must declare at least one identity provider (IdP) per SP 3) 
Finally, you can call <code>saml_authenticate(+SP, +IdP, +Callback, +Request)</code> 
to obtain assertions The asynchronous nature of the SAML process means 
that a callback must be used. Assuming that the IdP was able to provide 
at least some valid assertions about the user, after calling Callback 
with 2 extra arguments (a list of the assertion terms and the URL being 
request by the user), the user will be redirected back to their original 
URL. It is therefore up to the callback to ensure that this does not 
simply trigger another round of SAML negotiations - for example, by 
throwing <code>http_reply(forbidden(RequestURL))</code> if the 
assertions are not strong enough 4) Finally, your SP metadata will be 
available from the web server directly. This is required to configure 
the IdP. This will be available at './metadata.xml', relative to the 
LocationSpec provided when the SP was declared.
</blockquote>
<div style="text-align:center"> Configuring an SP: To declare an SP, use 
the declaration
<code>:-</code><code>saml_sp(+ServiceProvider: atom, +LocationSpec: term, +PrivateKeySpec: term, +Password: atom +CertificateSpec: term, +Options: list)</code>.
</div>
<blockquote> The ServiceProvider is the identifier of your service. 
Ideally, this should be a fully-qualified URI The LocationSpec is a 
location that the HTTP dispatch layer will understand for example '.' or <code>root('saml')</code>. 
The Private KeySpec is a 'file specifier' that resolves to a private key 
(see below for specifiers) The Password is a password used for reading 
the private key. If the key is not encrypted, any atom can be supplied 
as it will be ignored The CertificateSpec is a file specifier that 
resolves to a certificate holding the public key corresponding to 
PrivateKeySPec There are currently no implemented options (the list is 
ignored).
</blockquote>
<div style="text-align:center"> Configuring an IdP: To declare an IdP, 
use the declaration
<code>:-</code><code>saml_idp(+ServiceProvider: atom, +MetadataSpec: term)</code>. 
ServiceProvider is the identifier used when declaring your SP. You do 
not need to declare them in a particular order, but both must be present 
in the system before running <span class="pred-ext">saml_authenticate/4</span>. 
MetadataSpec is a file specifier that resolves to the metadata for the 
IdP. Most IdPs will be able to provide this on request
</div>
<blockquote> File Specifiers: The following specifiers are supported for 
locating files:
</blockquote>

<p>
<ul class="latex">
<li><code>file(Filename)</code>: The local file Filename
<li><code>resource(Resource)</code>: The prolog resource Resource. See <span class="pred-ext">resource/3</span>
<li><code>url(URL)</code>: The file identified by the HTTP (or HTTPS if 
you have the HTTPS plugin loaded) URL
</ul>
</dd>
</dl>

<p>This library uses SAML to exchange messages with an Identity Provider 
to establish assertions about the current user's session. It operates 
only as the service end, not the identity provider end.

<p><h3 id="sec:xmlenc"><a id="sec:4.2"><span class="sec-nr">4.2</span> <span class="sec-title">library(xmlenc): 
XML encryption library</span></a></h3>

<p><a id="sec:xmlenc"></a>

<dl class="tags">
<dt class="mtag">See also</dt>
<dd>
- <a class="url" href="https://www.w3.org/TR/xmlenc-core1/">https://www.w3.org/TR/xmlenc-core1/</a> <br>
- <a class="url" href="https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language">https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language</a>
</dd>
</dl>

<p>This library is a partial implementation of the XML encryption 
standard. It implements the <i>decryption</i> part, which is needed by 
SAML clients.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="decrypt_xml/4"><strong>decrypt_xml</strong>(<var>+DOMIn, 
-DOMOut, :KeyCallback, +Options</var>)</a></dt>
<dd class="defbody">
<table class="arglist">
<tr><td><var>KeyCallback</var> </td><td>may be called as follows:

<p>
<ul class="compact">
<li><code>call(KeyCallback, name, KeyName, Key)</code>
<li><code>call(KeyCallback, public_key, public_key(RSA), Key)</code>
<li><code>call(KeyCallback, certificate, Certificate, Key)</code>
</ul>

<p></td></tr>
</table>
</dd>
</dl>

<p><h3 id="sec:xmldsig"><a id="sec:4.3"><span class="sec-nr">4.3</span> <span class="sec-title">library(xmldsig): 
XML Digital signature</span></a></h3>

<p><a id="sec:xmldsig"></a>

<dl class="tags">
<dt class="mtag">See also</dt>
<dd>
- <a class="url" href="http://www.di-mgt.com.au/xmldsig.html">http://www.di-mgt.com.au/xmldsig.html</a> <br>
- <a class="url" href="https://www.bmt-online.org/geekisms/RSA_verify">https://www.bmt-online.org/geekisms/RSA_verify</a> <br>
- <a class="url" href="http://stackoverflow.com/questions/5576777/whats-the-difference-between-nid-sha-and-nid-sha1-in-openssl">http://stackoverflow.com/questions/5576777/whats-the-difference-between-nid-sha-and-nid-sha1-in-openssl</a>
</dd>
</dl>

<p>This library deals with <i>XMLDSIG</i>, RSA signed XML documents.

<dl class="latex">
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="xmld_signed_DOM/3"><strong>xmld_signed_DOM</strong>(<var>+DOM, 
-SignedDOM, +Options</var>)</a></dt>
<dd class="defbody">
Translate an XML <var>DOM</var> structure in a signed version. <var>Options</var>:

<dl class="latex">
<dt><strong>key_file</strong>(<var>+File</var>)</dt>
<dd class="defbody">
<var>File</var> holding the private key needed to sign
</dd>
<dt><strong>key_password</strong>(<var>+Password</var>)</dt>
<dd class="defbody">
String holding the password to op the private key.
</dd>
</dl>

<p>The <var>SignedDOM</var> must be emitted using <span class="pred-ext">xml_write/3</span> 
or
<span class="pred-ext">xml_write_canonical/3</span>. If <span class="pred-ext">xml_write/3</span> 
is used, the option
<code>layout(false)</code> is needed to avoid changing the layout of the
<code>SignedInfo</code> element and the signed <var>DOM</var>, which 
will cause the signature to be invalid.</dd>
<dt class="pubdef"><span class="pred-tag">[det]</span><a id="xmld_verify_signature/4"><strong>xmld_verify_signature</strong>(<var>+DOM, 
+SignatureDOM, -Certificate, +Options</var>)</a></dt>
<dd class="defbody">
Confirm that an <code>ds:Signature</code> element contains a valid 
signature. <var>Certificate</var> is bound to the certificate that 
appears in the element if the signature is valid. It is up to the caller 
to determine if the certificate is trusted or not.

<p><b>Note</b>: The <var>DOM</var> and <var>SignatureDOM</var> must have 
been obtained using the <span class="pred-ext">load_structure/3</span> 
option <code>keep_prefix(true)</code> otherwise it is impossible to 
generate an identical document for checking the signature. See also <span class="pred-ext">xml_write_canonical/3</span>.
</dd>
</dl>

<p><h2 id="sec:ssl-security"><a id="sec:5"><span class="sec-nr">5</span> <span class="sec-title">SSL 
Security</span></a></h2>

<a id="sec:ssl-security"></a>

<p>Using SSL (in this particular case based on the OpenSSL 
implementation) to connect to SSL services (e.g., an <code>https://</code> 
address) easily gives a false sense of security. This section explains 
some of the pitfalls.<sup class="fn">1<span class="fn-text">We do not 
claim to be complete, just to start warning you if security is important 
to you. Please make sure you understand (Open)SSL before relying on it.</span></sup>. 
As stated in the introduction, SSL aims at solving two issues: tapping 
information from the wire by means of encryption and make sure that you 
are talking to the right address.

<p>Encryption is generally well arranged as long as you ensure that the 
underlying SSL library has all known security patches installed and you 
use an encryption that is not known to be weak. The Windows version of 
SWI-Prolog ships with its own binary of the OpenSSL library. Ensure this 
is up-to-date. Most other systems ship with the OpenSSL library and 
SWI-Prolog uses the system version. This applies for the binaries we 
distribute for MacOSX and Linux, as well as official Linux packages. 
Check the origin and version of the OpenSSL libraries if SWI-Prolog was 
compiled from source. The OpenSSL library version as reported by 
SSLeay_version() is available in the Prolog flag
<code>ssl_library_version</code> as illustrated below on Ubuntu 14.04.

<pre class="code">
?- [library(ssl)].
?- current_prolog_flag(ssl_library_version, X).
X = 'OpenSSL 1.0.1f 6 Jan 2014'.
</pre>

<p>Whether you are talking to the right address is a complicated issue. 
The core of the validation is that the server provides a
<em>certificate</em> that identifies the server. This certificate is 
digitally <em>signed</em> by another certificate, and ultimately by a
<em>root certificate</em>. (There may be additional links in this chain 
as well, or there may just be one certificate signed by itself) 
Verifying the peer implies:

<p>
<ol class="latex">
<li>Verifying the chain or digital signatures until a trusted root 
certificate is found, taking care that the chain does not contain any 
invalid certificates, such as certificates which have expired, are not 
yet valid, have altered or forged signatures, are valid for the purposes 
of SSL (and in the case of an issuer, issuing child certificates)
<li>Verifying that the signer of a certificate did not <em>revoke</em> 
the signed certificate.
<li>Verifying that the host we connected to is indeed the host claimed 
in the certificate.
</ol>

<p>The default https client plugin (<code>library(http/http_ssl_plugin)</code>) 
registers the system trusted root certificate with OpenSSL. This is 
achieved using the option
<code>cacert_file(system(root_certificates))</code> of <a id="idx:sslcontext3:2"></a><a class="pred" href="#ssl_context/3">ssl_context/3</a>. 
The verification is left to OpenSSL. To the best of our knowledge, the 
current (1.0) version of OpenSSL <b>only</b> implements step (1) of the 
verification process outlined above. This implies that an attacker that 
can control DNS mapping (host name to IP) or routing (IP to physical 
machine) can fake to be a secure host as long as they manage to obtain a 
certificate that is signed from a recognised authority. Version 1.0.2 
supports hostname checking, and will not validate a certificate chain if 
the leaf certificate does not match the hostname. 'Match' here is not a 
simple string comparison; certificates are allowed (subject to many 
rules) to have wildcards in their SubjectAltName field. Care must also 
be taken to ensure that the name we are checking against does not 
contain embedded NULLs. If SWI-Prolog is compiled against a version of 
OpenSSL that does NOT have hostname checking (ie 1.0.0 or earlier), it 
will attempt to do the validation itself. This is not guaranteed to be 
perfect, and it only supports a small subset of allowed wildcards. If 
security is important, use OpenSSL 1.0.2 or higher.

<p>After validation, the predicate <a id="idx:sslpeercertificate2:3"></a><a class="pred" href="#ssl_peer_certificate/2">ssl_peer_certificate/2</a> 
can be used to obtain the peer certificate and inspect its properties.

<p><h2 id="sec:crl"><a id="sec:6"><span class="sec-nr">6</span> <span class="sec-title">CRLs 
and Revocation</span></a></h2>

<a id="sec:crl"></a> Certificates must sometimes be revoked. 
Unfortunately this means that the elegant chain-of-trust model breaks 
down, since the information you need to determine whether a certificate 
is trustworthy no longer depends on just the certificate and whether the 
issuer is trustworthy, but now on a third piece of data - whether the 
certificate has been revoked. These are managed in two ways in OpenSSL: 
CRLs and OCSP. SWI-Prolog supports CRLs only. (Typically OCSP responders 
are configured in such a way as to just consult CRLs anyway. This gives 
the illusion of up-to-the-minute revocation information because OCSP is 
an interactive, online, real-time protocol. However the information 
provided can still be several <em>weeks</em> out of date!)

<p>To do CRL checking, pass require_crl(true) as an option to the
<a id="idx:sslcontext3:4"></a><a class="pred" href="#ssl_context/3">ssl_context/3</a> 
(or <a id="idx:httpopen3:5"></a><span class="pred-ext">http_open/3</span>) 
option list. If you do this, a certificate will not be validated unless 
it can be <em>checked</em> for on a revocation list. There are two 
options for this:

<p>First, you can pass a list of filenames in as the option <a id="idx:crl1:6"></a><span class="pred-ext">crl/1</span>. 
If the CRL corresponds to an issuer in the chain, and the issued 
certificate is not on the CRL, then it is assumed to not be revoked. 
Note that this does NOT prove the certificate is actually trustworthy - 
the CRL you pass may be out of date! This is quite awkward to get right, 
since you do not necessarily know in advance what the chain of 
certificates the other party will present are, so you cannot reasonably 
be expected to know which CRLs to pass in.

<p>Secondly, you can handle the CRL checking in the cert_verify_hook 
when the Error is bound to unknown_crl. At this point you can obtain the 
issuer certificate (also given in the hook), find the CRL distribution 
point on it (the <a id="idx:crl1:7"></a><span class="pred-ext">crl/1</span> 
argument), try downloading the CRL (the URL can have literally any 
protocol, most commonly HTTP and LDAP, but theoretically anything else, 
too, including the possibility that the certificate has no CRL 
distribution point given, and you are expected to obtain the CRL by 
email, fax, or telegraph. Therefore how to actually obtain a CRL is out 
of scope of this document), load it using <a id="idx:loadcrl2:8"></a><a class="pred" href="#load_crl/2">load_crl/2</a>, 
then check to see whether the certificate currently under scrutiny 
appears in the list of revocations. It is up to the application to 
determine what to do if the CRL cannot be obtained - either because the 
protocol to obtain it is not supported or because the place you are 
obtaining it from is not responding. Just because the CRL server is not 
responding does not mean that your certificate is safe, of course - it 
has been suggested that an ideal way to extend the life of a stolen 
certificate key would be to force a denial of service of the CRL server.

<p><h4 id="sec:disable-certificate"><a id="sec:6.1"><span class="sec-nr">6.1</span> <span class="sec-title">Disabling 
certificate checking</span></a></h4>

<a id="sec:disable-certificate"></a>

<p>In some cases clients are not really interested in host validation of 
the peer and whether or not the certificate can be trusted. In these 
cases the client can pass <code>cert_verify_hook(cert_accept_any)</code>, 
calling <a id="idx:certacceptany5:9"></a><a class="pred" href="#cert_accept_any/5">cert_accept_any/5</a> 
which accepts any certificate. Note that this will accept literally ANY 
certificate presented - including ones which have expired, have been 
revoked, and have forged signatures. This is probably not a good idea!

<p><h4 id="sec:ssl-safe-connection"><a id="sec:6.2"><span class="sec-nr">6.2</span> <span class="sec-title">Establishing 
a safe connection</span></a></h4>

<a id="sec:ssl-safe-connection"></a>

<p>Applications that exchange sensitive data with e.g., a backend server 
typically need to ensure they have a secure connection to their peer. To 
do this, first obtain a non-secure connection to the peer (eg via a TCP 
socket connection). Then create an SSL context via
<a id="idx:sslcontext3:10"></a><a class="pred" href="#ssl_context/3">ssl_context/3</a>. 
For the client initiating the connection, the role is 'client', and you 
should pass options <a id="idx:host1:11"></a><span class="pred-ext">host/1</span> 
and <a id="idx:cacertfile1:12"></a><span class="pred-ext">cacert_file/1</span> 
at the very least. If you expect the peer to have a certificate which 
would be accepted by your host system, you can pass
<code>cacert_file(system(root_certificates))</code>, otherwise you will 
need a copy of the CA certificate which was used to sign the peer's 
certificate. Alternatively, you can pass <a id="idx:certverifyhook1:13"></a><span class="pred-ext">cert_verify_hook/1</span> 
to write your own custom validation for the peer's certificate. 
Depending on the requirements, you may also have to provide your /own/ 
certificate if the peer demands mutual authentication. This is done via 
the
<a id="idx:certificatefile1:14"></a><span class="pred-ext">certificate_file/1</span>, <a id="idx:keyfile1:15"></a><span class="pred-ext">key_file/1</span> 
and either <a id="idx:password1:16"></a><span class="pred-ext">password/1</span> 
or
<a id="idx:pempasswordhook1:17"></a><span class="pred-ext">pem_password_hook/1</span>.

<p>Once you have the SSL context and the non-secure stream, you can call
<a id="idx:sslnegotiate5:18"></a><a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a> 
to obtain a secure stream. <a id="idx:sslnegotiate5:19"></a><a class="pred" href="#ssl_negotiate/5">ssl_negotiate/5</a> 
will raise an exception if there were any certificate errors that could 
not be resolved.

<p>The peer behaves in a symmetric fashion: First, a non-secure 
connection is obtained, and a context is created using <a id="idx:sslcontext3:20"></a><a class="pred" href="#ssl_context/3">ssl_context/3</a> 
with the role set to server. In the server case, you must provide
<a id="idx:certificatefile1:21"></a><span class="pred-ext">certificate_file/1</span> 
and <a id="idx:keyfile1:22"></a><span class="pred-ext">key_file/1</span>, 
and then either <a id="idx:password1:23"></a><span class="pred-ext">password/1</span> 
or
<a id="idx:pempasswordhook1:24"></a><span class="pred-ext">pem_password_hook/1</span>. 
If you require the other party to present a certificate as well, then 
peer_cert(true) should be provided. If the peer does not present a 
certificate, or the certificate cannot be validated as trusted, the 
connection will be rejected.

<p>By default, revocation is not checked. To enable certificate 
revocation checking, pass require_crl(true) when creating the SSL 
context. See <a class="sec" href="#sec:6">section 6</a> for more 
information about revocations.

<p><h2 id="sec:ssl-examples"><a id="sec:7"><span class="sec-nr">7</span> <span class="sec-title">Example 
code</span></a></h2>

<a id="sec:ssl-examples"></a>

<p>Examples of a simple server and client (<code>server.pl</code> and
<code>client.pl</code> as well as a simple HTTPS server (<code>https.pl</code>) 
can be found in the example directory which is located in
<code>doc/packages/examples/ssl</code> relative to the SWI-Prolog 
installation directory. The <code>etc</code> directory contains example 
certificate files as well as a <code>README</code> on the creation of 
certificates using OpenSSL tools.

<p><h3 id="sec:ssl-https-client"><a id="sec:7.1"><span class="sec-nr">7.1</span> <span class="sec-title">Accessing 
an HTTPS server</span></a></h3>

<a id="sec:ssl-https-client"></a>

<p>Accessing an <code>https://</code> server can be achieved using the 
code skeleton below. The line <code>:- use_module(library(http/http_ssl_plugin)).</code> 
can actually be omitted because the plugin is dynamically loaded by
<a id="idx:httpopen3:25"></a><span class="pred-ext">http_open/3</span> 
if the <code>https</code>&nbsp;scheme is detected. See <a class="sec" href="#sec:5">section 
5</a> for more information about security aspects.

<pre class="code">
:- use_module(library(http/http_open)).
:- use_module(library(http/http_ssl_plugin)).

    ...,
    http_open(HTTPS_url, In, []),
    ...
</pre>

<p><h3 id="sec:ssl-https-server"><a id="sec:7.2"><span class="sec-nr">7.2</span> <span class="sec-title">Creating 
an HTTPS server</span></a></h3>

<a id="sec:ssl-https-server"></a>

<p>The SWI-Prolog infrastructure provides two main ways to launch an 
HTTPS&nbsp;server:

<p>
<ul class="latex">
<li>Using <code>library(http/thread_httpd)</code>, the server is started 
in HTTPS&nbsp;mode by adding an option&nbsp;<code>ssl/1</code> to
<a id="idx:httpserver2:26"></a><span class="pred-ext">http_server/2</span>. 
The argument of <code>ssl/1</code> is an option list that is passed as 
the third argument to <a id="idx:sslcontext3:27"></a><a class="pred" href="#ssl_context/3">ssl_context/3</a>.
<li>Using <code>library(http/http_unix_daemon)</code>, an HTTPS&nbsp;server 
is started by using the command line argument&nbsp;<code>--https</code>.
</ul>

<p>Two items are typically specified as, respectively, options or 
additional command&nbsp;line arguments:

<p>
<ul class="latex">
<li><b>server certificate</b>. This identifies the server and acts as a <em>public 
key</em> for the encryption.
<li><b>private key</b> of the server, which must be kept secret. The key <i>may</i> 
be protected by a password. If this is the case, the server must provide 
the password by means of the
<code>password</code> option, the <code>pem_password_hook</code> 
callback or, in case of the Unix daemon, via the <code>--pwfile</code> 
or
<code>--password</code> command line options.
</ul>

<p>Here is an example that uses the self-signed demo certificates 
distributed with the SSL package. As is typical for publicly accessible 
HTTPS&nbsp;servers, this version does <i>not</i> require a certificate 
from the&nbsp;client:

<pre class="code">
:- use_module(library(http/thread_httpd)).
:- use_module(library(http/http_ssl_plugin)).

https_server(Port, Options) :-
        http_server(reply,
                    [ port(Port),
                      ssl([ certificate_file('etc/server/server-cert.pem'),
                            key_file('etc/server/server-key.pem'),
                            password("apenoot1")
                          ])
                    | Options
                    ]).
</pre>

<p>There are two <em>hooks</em> that let you extend HTTPS servers with 
custom definitions:

<p>
<ul class="latex">
<li><code>http:ssl_server_create_hook(+SSL0, -SSL, +Options)</code>: 
This extensible predicate is called exactly <i>once</i>, after creating 
an HTTPS&nbsp;server with Options. If this predicate succeeds,
<code>SSL</code> is the&nbsp;context that is used for negotiating all 
new connections. Otherwise, <code>SSL0</code> is used, which is the 
context that was created with the given options.
<li><code>http:ssl_server_open_client_hook(+SSL0, -SSL, +Options)</code>: 
This predicate is called before <i>each</i> connection that the server 
negotiates with a client. If this predicate succeeds, <code>SSL</code> 
is the context that is used for the new&nbsp;connection. Otherwise, <code>SSL0</code> 
is&nbsp;used, which is the context that was created when launching the&nbsp;server.
</ul>

<p>Important use cases of these hooks are running dual-stack RSA/ECDSA 
servers, and updating certificates while the server keeps running.

<p>The example file <code>https.pl</code> also provides a server that
<i>does</i> require the client to show its certificate. This provides an 
additional level of security, often used to allow a selected set of 
clients to perform sensitive tasks.

<p>Note that a single Prolog program can call <a id="idx:httpserver2:28"></a><span class="pred-ext">http_server/2</span> 
with different parameters to provide services at several security levels 
as described below. These servers can either use their own dispatching 
or commonly use <a id="idx:httpdispatch1:29"></a><span class="pred-ext">http_dispatch/1</span> 
and check the <code>port</code> property of the request to verify they 
are called with the desired security level. If a service is approached 
at a too low level of security, the handler can deny access or use HTTP 
redirect to send the client to to appropriate interface.

<p>
<ul class="latex">
<li>A plain HTTP server at port 80. This can either be used for 
non-sensitive information or for <em>redirecting</em> to a more secure 
service.
<li>An HTTPS server at port 443 for sensitive services to the general 
public.
<li>An HTTPS server that demands for a client key on a selected port for 
administrative tasks or sensitive machine-to-machine communication.
</ul>

<p><h3 id="sec:https-proxy"><a id="sec:7.3"><span class="sec-nr">7.3</span> <span class="sec-title">HTTPS 
behind a proxy</span></a></h3>

<a id="sec:https-proxy"></a>

<p>The above expects Prolog to be accessible directly from the internet. 
This is becoming more popular now that services are often deployed using <em>virtualization</em>. 
If the Prolog services are placed behind a reverse proxy, HTTPS 
implementation is the task of the proxy server (e.g., Apache or Nginx). 
The communication from the proxy server to the Prolog server can use 
either plain HTTP or HTTPS. As plain HTTP is easier to setup and faster, 
this is typically preferred if the network between the proxy server and 
Prolog server can be trusted.

<p>Note that the proxy server <em>must</em> decrypt the HTTPS traffic 
because it must decide on the destination based on the encrypted HTTP 
header.
<em>Port forwarding</em> provides another option to make a server 
running on a machine that is not directly connected to the internet 
visible. It is not needed to decrypt the traffic using port forwarding, 
but it is also not possible to realise <em>virtual hosts</em> or
<em>path-based</em> proxy rules.

<p>Virtual hosts for HTTPS are available via <em>Server Name Indication</em>&nbsp;(SNI). 
This is a TLS extension that allows servers to host different domains 
from the same IP address. See the <a id="idx:snihook1:30"></a><span class="pred-ext">sni_hook/1</span> 
option of <a id="idx:sslcontext3:31"></a><a class="pred" href="#ssl_context/3">ssl_context/3</a> 
for more information.

<p><h2 id="sec:ssl-acknowledgments"><a id="sec:8"><span class="sec-nr">8</span> <span class="sec-title">Acknowledgments</span></a></h2>

<a id="sec:ssl-acknowledgments"></a>

<p>The development of the SWI-Prolog SSL interface has been sponsored by
<a class="url" href="http://www.sss.co.nz">Scientific Software and 
Systems Limited</a>. The current version contains contributions from 
many people. Besides the mentioned authors, <a class="url" href="https://www.metalevel.at">Markus 
Triska</a> has submitted several patches, and improved and documented 
the integration of this package with the HTTP infrastructure.

<h1><a id="document-index">Index</a></h1>

<dl>
<dt class="index-sep">?</dt>
<dt>cacert_file/1</dt>
<dd>
<a class="idx" href="#idx:cacertfile1:12">6.2</a></dd>
<dt><a class="idx" href="#cert_accept_any/5">cert_accept_any/5</a></dt>
<dd>
<a class="idx" href="#idx:certacceptany5:9">6.1</a></dd>
<dt>cert_verify_hook/1</dt>
<dd>
<a class="idx" href="#idx:certverifyhook1:13">6.2</a></dd>
<dt>certificate_file/1</dt>
<dd>
<a class="idx" href="#idx:certificatefile1:14">6.2</a> <a class="idx" href="#idx:certificatefile1:21">6.2</a></dd>
<dt>crl/1</dt>
<dd>
<a class="idx" href="#idx:crl1:6">6</a> <a class="idx" href="#idx:crl1:7">6</a></dd>
<dt><a class="idx" href="#crypto_context_hash/2">crypto_context_hash/2</a></dt>
<dt><a class="idx" href="#crypto_context_new/2">crypto_context_new/2</a></dt>
<dt><a class="idx" href="#crypto_data_context/3">crypto_data_context/3</a></dt>
<dt><a class="idx" href="#crypto_data_hash/3">crypto_data_hash/3</a></dt>
<dt><a class="idx" href="#crypto_file_hash/3">crypto_file_hash/3</a></dt>
<dt><a class="idx" href="#crypto_open_hash_stream/3">crypto_open_hash_stream/3</a></dt>
<dt><a class="idx" href="#crypto_stream_hash/2">crypto_stream_hash/2</a></dt>
<dt><a class="idx" href="#decrypt_xml/4">decrypt_xml/4</a></dt>
<dt><a class="idx" href="#ecdsa_sign/4">ecdsa_sign/4</a></dt>
<dt><a class="idx" href="#ecdsa_verify/4">ecdsa_verify/4</a></dt>
<dt><a class="idx" href="#evp_decrypt/6">evp_decrypt/6</a></dt>
<dt><a class="idx" href="#evp_encrypt/6">evp_encrypt/6</a></dt>
<dt><a class="idx" href="#hex_bytes/2">hex_bytes/2</a></dt>
<dt>host/1</dt>
<dd>
<a class="idx" href="#idx:host1:11">6.2</a></dd>
<dt>http_dispatch/1</dt>
<dd>
<a class="idx" href="#idx:httpdispatch1:29">7.2</a></dd>
<dt>http_open/3</dt>
<dd>
<a class="idx" href="#idx:httpopen3:1">1</a> <a class="idx" href="#idx:httpopen3:5">6</a> <a class="idx" href="#idx:httpopen3:25">7.1</a></dd>
<dt>http_server/2</dt>
<dd>
<a class="idx" href="#idx:httpserver2:26">7.2</a> <a class="idx" href="#idx:httpserver2:28">7.2</a></dd>
<dt>key_file/1</dt>
<dd>
<a class="idx" href="#idx:keyfile1:15">6.2</a> <a class="idx" href="#idx:keyfile1:22">6.2</a></dd>
<dt><a class="idx" href="#load_certificate/2">load_certificate/2</a></dt>
<dt><a class="idx" href="#load_crl/2">load_crl/2</a></dt>
<dd>
<a class="idx" href="#idx:loadcrl2:8">6</a></dd>
<dt><a class="idx" href="#load_private_key/3">load_private_key/3</a></dt>
<dt><a class="idx" href="#load_public_key/2">load_public_key/2</a></dt>
<dt>password/1</dt>
<dd>
<a class="idx" href="#idx:password1:16">6.2</a> <a class="idx" href="#idx:password1:23">6.2</a></dd>
<dt>pem_password_hook/1</dt>
<dd>
<a class="idx" href="#idx:pempasswordhook1:17">6.2</a> <a class="idx" href="#idx:pempasswordhook1:24">6.2</a></dd>
<dt><a class="idx" href="#rsa_private_decrypt/4">rsa_private_decrypt/4</a></dt>
<dt><a class="idx" href="#rsa_private_encrypt/4">rsa_private_encrypt/4</a></dt>
<dt><a class="idx" href="#rsa_public_decrypt/4">rsa_public_decrypt/4</a></dt>
<dt><a class="idx" href="#rsa_public_encrypt/4">rsa_public_encrypt/4</a></dt>
<dt><a class="idx" href="#rsa_sign/4">rsa_sign/4</a></dt>
<dt><a class="idx" href="#rsa_verify/4">rsa_verify/4</a></dt>
<dt>sni_hook/1</dt>
<dd>
<a class="idx" href="#idx:snihook1:30">7.3</a></dd>
<dt><a class="idx" href="#ssl_add_certificate_key/4">ssl_add_certificate_key/4</a></dt>
<dt><a class="idx" href="#ssl_context/3">ssl_context/3</a></dt>
<dd>
<a class="idx" href="#idx:sslcontext3:2">5</a> <a class="idx" href="#idx:sslcontext3:4">6</a> <a class="idx" href="#idx:sslcontext3:10">6.2</a> <a class="idx" href="#idx:sslcontext3:20">6.2</a> <a class="idx" href="#idx:sslcontext3:27">7.2</a> <a class="idx" href="#idx:sslcontext3:31">7.3</a></dd>
<dt><a class="idx" href="#ssl_negotiate/5">ssl_negotiate/5</a></dt>
<dd>
<a class="idx" href="#idx:sslnegotiate5:18">6.2</a> <a class="idx" href="#idx:sslnegotiate5:19">6.2</a></dd>
<dt><a class="idx" href="#ssl_peer_certificate/2">ssl_peer_certificate/2</a></dt>
<dd>
<a class="idx" href="#idx:sslpeercertificate2:3">5</a></dd>
<dt><a class="idx" href="#ssl_peer_certificate_chain/2">ssl_peer_certificate_chain/2</a></dt>
<dt><a class="idx" href="#ssl_session/2">ssl_session/2</a></dt>
<dt><a class="idx" href="#ssl_set_sni_hook/3">ssl_set_sni_hook/3</a></dt>
<dt><a class="idx" href="#system_root_certificates/1">system_root_certificates/1</a></dt>
<dt><a class="idx" href="#xmld_verify_signature/4">xmld_verify_signature/4</a></dt>
<dt><a class="idx" href="#xmld_signed_DOM/3">xmld_signed_DOM/3</a></dt>
<dd>
</dd>
</dl>

</body></html>